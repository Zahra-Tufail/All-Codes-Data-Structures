#include<iostream>
using namespace std;
template <class t>
class binary_node
{
public:
    t element;
    binary_node<t>* left_tree;
    binary_node<t>* right_tree;
public:
    binary_node(t obj)
    {
        element = obj;
        left_tree = nullptr;
        right_tree = nullptr;
    }

    t retrieve() const
    {
        return element;
    }

    binary_node* left()
    {
        return left_tree;
    }

    binary_node* right()
    {
        return right_tree;
    }

    bool is_leaf()
    {
        return (!empty() && left()->empty() && right()->empty());
    }

    bool empty()
    {
        return (this == nullptr);
    }

    int size()
    {
        return empty() ? 0 : 1 + left()->size() + right()->size();
    }

    int height()
    {
        return empty() ? -1 : 1 + std::max(left()->height(), right()->height());
    }

    void clear(binary_node* to_this)
    {
        if (empty())
        {
            return;
        }
        left()->clear(left_tree);
        right()->clear(right_tree);
        delete this;
        to_this = nullptr; // for making the pointer null that was pointing to the tree that is to be deleted  
    }
};
template <class t>
class Binary_Tree
{
public:
    binary_node<t>* root_node;

    Binary_Tree()
    {
        root_node = nullptr;
    }

    binary_node<t>* root()
    {
        return root_node;
    }

    bool empty()
    {
        return (root_node == nullptr);
    }
    
    int size_b()
    {
        return (empty()) ? 0 : root->size_b();
    }

    int height_b()
    {
        return (empty()) ? -1 : root->height_b();
    }

    //traversals
    void inorder(binary_node<t>* r) //left(1) root(+) right(2) -> (1 + 2)
    {
        if (r != nullptr)
        {
            inorder(r->left());
            cout << "\n Node :" << r->retrieve();
            inorder(r->right());
        }
    }

    void postorder(binary_node<t>* r) //left(1) right(2)  root(+)  -->  12+
    {
        if (r != nullptr)
        {
            postorder(r->left());
            postorder(r->right());
            cout << "\n Node :" << r->retrieve();
        }
    }

    void preoder(binary_node<t>* r) //root(+) left(1) right(2) --> +12
    {
        if (r != nullptr)
        {
            cout << "\n Node :" << r->retrieve();
            postorder(r->left());
            postorder(r->right());
        }
    }
};
int main()
{
    Binary_Tree<int> tree;
    tree.root_node = new binary_node<int>(10);
    tree.root_node->left_tree = new binary_node<int>(5);
    tree.root_node->right_tree = new binary_node<int>(20);
    
    tree.root_node->left_tree->left_tree = new binary_node<int>(3);
    tree.root_node->left_tree->right_tree = new binary_node <int>(7);
    cout << "\n Inorder traversal: ";
    tree.inorder(tree.root_node);
    cout << "\n Postorder traversal: ";
    tree.postorder(tree.root_node);
    cout << "\n Preorder traversal: ";
    tree.preoder(tree.root_node);

}
